#pragma kernel FlockingKernel
#pragma kernel KinematicKernel
struct BoidData{
    float3 position;
    float scale;
    float3 velocity;
    float dummy;
};

RWStructuredBuffer<BoidData> _BoidsBuffer;
RWStructuredBuffer<float3> _BoidsNetForces;

uniform float _DeltaTime;
uniform float _Time;

cbuffer once {
  float _Radius;
  float _MaxSpeed;
  float _MaxForce;
  uint _Instances;
  uint _MassPerUnit;
  float3 _MaxBound;
  float3 _MinBound;
};

float3 _ForceWeights;
float3 ClampPointToBounds(float3 p)
{
return clamp(p, _MinBound, _MaxBound);
}
float aMod(float a, float n)
{
    return a - n * floor(a / n);
}
float ReflectCube(float val, float min, float max)
{
    float E = max - min;
    float R = (min + aMod((val - min), E));
    float t = aMod(ceil((val - min) / E), 2.0);
    return R * (2.0 * t - 1.0) + (max + min) * (1 - t);
}
float3 ReflectPointInBounds(float3 p)
{
    float x = ReflectCube(p.x, _MinBound.x, _MaxBound.x);
    float y = ReflectCube(p.y, _MinBound.y, _MaxBound.y);
    float z = ReflectCube(p.z, _MinBound.z, _MaxBound.z);
    return float3(x, y, z);
}
//https://twitter.com/_Humus_/status/1074973351276371968?s=20
bool IsNaN(float3 v)
{
     return (asuint(v.x) & 0x7FFFFFFF) > 0x7F800000 &&
     (asuint(v.y) & 0x7FFFFFFF) > 0x7F800000 &&
     (asuint(v.z) & 0x7FFFFFFF) > 0x7F800000;
}
float rand(float2 n) { 
	return frac(sin(dot(n, float2(12.9898, 4.1414))) * 43758.5453);
}

float3 hash31(float p)
{
   float3 p3 = frac(p * float3(.1031, .1030, .0973));
   p3 += dot(p3, p3.yzx+33.33);
   return frac((p3.xxy+p3.yzz)*p3.zyx); 
}
#define E 0.0000001
#define Rot(a)  float2x2(cos(a), sin(a),-sin(a), cos(a))
#define pi acos(-1)
#define InvLaw(x) 1/(1+ x*x +x)

[numthreads(512,1,1)]
void FlockingKernel (uint3 id : SV_DispatchThreadID)
{
   if(id.x >=_Instances )
   {
    return;
   }
  BoidData boid = _BoidsBuffer[id.x];
  float sepLength,weight,currentSpeed;
  float ForceInteractions = _Instances;
  float3 FRep=0,FAtt=0,FAli=0, FOrSeparation=0;


  [loop]for (uint bn = 0; bn < _Instances; bn++)
  {
    BoidData neighbour = _BoidsBuffer[bn];
    FOrSeparation = boid.position - neighbour.position; //eparation vector using declared flot3 for register pressure
    sepLength = max(length(FOrSeparation),E);
    weight = sepLength /(_Radius+ boid.scale);
    ForceInteractions -= weight > 1 || sepLength <= E;
    weight = 1.0f - min(weight, 1.0f);
    weight = smoothstep(0,1.0,weight);
    FRep += (FOrSeparation / sepLength) * weight * _MaxForce;
    FAtt += neighbour.position * ceil(weight);
    FAli += neighbour.velocity * ceil(weight);
  }
  FOrSeparation = -boid.velocity;
    
   FRep /= max(ForceInteractions,E);
   FRep = normalize(FRep) * _MaxForce;
   FRep = IsNaN(FRep)?0:FRep;
   
   FAtt /= (ForceInteractions + 1);
   FAtt -= boid.position;
   FAtt = normalize(FAtt) * _MaxForce;
   FAtt  =IsNaN(FAtt)?FOrSeparation:FAtt;
   
   FAli /=max(ForceInteractions,E);
   FAli = normalize(FAli) * _MaxForce;
   FAli  =IsNaN(FAli)?boid.velocity:FAli;

   _ForceWeights*=smoothstep (0,1,InvLaw(boid.scale));
   FOrSeparation = FRep*_ForceWeights.x +FAtt*_ForceWeights.y+FAli*_ForceWeights.z;
   weight= 1/(1+ForceInteractions*ForceInteractions +ForceInteractions);
    //wander weight
   FOrSeparation += normalize(boid.velocity+ (hash31(id.x+ _Time)*2.0-1.0))*(_Radius+boid.scale)* _MaxForce*weight;
   FOrSeparation/=(_ForceWeights.x+_ForceWeights.y+_ForceWeights.z+weight);
   
   _BoidsNetForces[id.x] =FOrSeparation;
   _BoidsBuffer[id.x] = boid;
  
}



[numthreads(512,1,1)]
void KinematicKernel (uint3 id : SV_DispatchThreadID)
{
   if(id.x >=_Instances )
   {
    return;
   }

   BoidData boid = _BoidsBuffer[id.x];
   float3 Vector   =  _BoidsNetForces[id.x] ; // ForceVector

    boid.dummy=1+2*exp(-boid.scale);

   float currentMagnitude = max(length(Vector), E); 
   Vector = (Vector / currentMagnitude) ;
   Vector = Vector * min(currentMagnitude, _MaxForce *  boid.dummy);
   
   Vector = Vector / (_MassPerUnit*boid.scale); //Acceleration vector
  
   Vector = boid.velocity + Vector * _DeltaTime; // Velocity Vector
   currentMagnitude = max(length(Vector), E);
   Vector = Vector / currentMagnitude * min(currentMagnitude, _MaxSpeed *  boid.dummy);
   
   float3 position = boid.position + Vector  * _DeltaTime;
   Vector = ReflectPointInBounds(position);
   
   currentMagnitude =  min(currentMagnitude, _MaxSpeed*  boid.dummy);
   Vector = normalize( Vector - boid.position) ; //reflected direction
   boid.dummy = smoothstep(-1,1, dot(Vector, normalize(boid.velocity))); 
   boid.velocity =Vector * currentMagnitude;
   boid.position =  ReflectPointInBounds(position);

   _BoidsBuffer[id.x] =boid  ;

}



